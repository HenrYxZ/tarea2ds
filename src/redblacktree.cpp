// Class automatically generated by Dev-C++ New Class wizard

#include "redblacktree.h" // class's header file

RedBlackTree::RedBlackTree(){
_root = NULL;
}                             

RedBlackTree::~RedBlackTree(){
                              
                              }

int RedBlackTree::find(string k){
    //si no encuentra devuelve -1
    if(_root == NULL)
		return -1;
	Node* actual = _root;

	while(true)
	{	// Binary Searcher
		if(actual == NULL)
			break;

        int comparison=cmp(actual->getKey(),k);
		if(comparison == 0)
			return actual->getValue();

		else if(comparison > 0)
			actual = actual->getLeft();

		else
			actual = actual->getRight();
	}

	return -1;      
}     

void RedBlackTree::insert(string k, int v){
     if(_root == NULL)
			{
				_root = new Node(k,v);
				_root->setisRed(false);
			}

			else
			{
				Node* actual = _root;
                bool continua = true;
				while(continua)
				{
                    int comparison=cmp(actual->getKey(),k);
					if(comparison >= 0)
					{
						// ----------------	LEFT case ------------------------------

						if(actual->getLeft() == NULL)
						{	//había espacio
							Node* nuevo = new Node(k,v);
							nuevo->setFather(actual);
							actual->setLeft(nuevo);
                            //no se si debería ser balance nuevo o actual
                            if( actual->isRed() )
							balance(nuevo);
							continua = false;
							break;
						}
						else
							actual = actual->getLeft();
					}

					else
					{
						// -------------------- RIGHT case -------------------------

						if(actual->getRight() == NULL)
						{
							Node* nuevo = new Node(k,v);
							nuevo->setFather(actual);
							actual->setRight(nuevo);
                            if( actual->isRed() )
							balance(nuevo);
							continua = false;
							break;
						}

						else
							actual = actual->getRight();

					}


				}//end of while(continua)

			}//end of else [case tree is not empty]

     
}

void RedBlackTree::remove(string k){
     //TO DO
}

void RedBlackTree::simpleRot(Node* n){
     
     Node* father = n->getFather();    
     Node* granpa = father->getFather();     //abuelo (puede ser NULL)
     Node* brother = n->getBrother();            //hermano (puede ser null)
     
     //cambiemos al padre de "padre" por el bisabuelo, a su vez si padre debe ser un hijo izquiero o derecho
      
     father->setFather( granpa->getFather() );      //setea a bisabuelo como padre de "padre"
     
     if(granpa->getFather() != NULL)
     {
        
       if(granpa->getFather()->getLeft() == granpa)
         
            granpa->getFather()->setLeft(father);  //setea a padre como hijo izquierdo 
       
       else
       
           granpa->getFather()->setRight(father);  //setea a padre como hijo izquierdo
          
     }
     
     if(father->getLeft() == n)         //el nuevo es un hijo izq
     {
        father->setRight(granpa);
        granpa->setFather(father);
        
        granpa->setLeft(brother);
        if(brother != NULL)
        brother->setFather(granpa);
        
     }
     
     else                          //el nuevo es un hijo der
     {
         father->setLeft(granpa);
         granpa->setFather(father);
         
         granpa->setRight(brother);
         if(brother != NULL)
         brother->setFather(granpa);
     
     }
     
     if(granpa == _root)
       _root = father;
     father = NULL;
     brother = NULL;
     granpa = NULL;
    
      
              
}// fin de simpleRot

void RedBlackTree::doubleRot(Node* n){
     
     Node* father = n->getFather(); 
     
     if(father->getLeft() == n)     //el "hijo" es un hijo izq
     {
        father->setLeft( n->getRight() );
        if(n->getRight() != NULL)
        n->getRight()->setFather( father );
        
        father->setFather( n );
        n->setRight( father );
     }
     
     else
     {
         father->setRight( n->getLeft() );
         if( n->getLeft() != NULL )
         n->getLeft()->setFather( father );
         
         father->setFather( n );
         n->setLeft( father );
     }
     balance(father);
}     


void RedBlackTree::balance(Node* n){
     
     if(n == _root)
     {
       _root->setisRed(false);  
       return;
     }
     
     Node* father = n->getFather();    
     Node* granpa = father->getFather();     //abuelo (también puede ser NULL)
     
     Node* uncle = father->getBrother();         //tío (puede ser NULL)
     
     //hijo rojo con padre rojo con sus 3 casos seguiran a continuación
     
     //tio rojo
     if( uncle!=NULL && uncle->isRed() )
     {
        uncle->recolor();
        granpa->recolor();
        father->recolor();  
     }
     //rotación simple      - luego se encarga de los casos simétricos
     else if( (granpa->getLeft() == father && father->getLeft() == n ) || ( granpa->getRight() == father && father->getRight() == n ) )
     {
          father->recolor();
          granpa->recolor();
          simpleRot(n);     
     }
     
     //rotación doble       - luego se encarga de los casos simétricos
     else
     {
         doubleRot(n);
     }
     
}

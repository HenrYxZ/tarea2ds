// Class automatically generated by Dev-C++ New Class wizard
#include <stack>
#include <iostream>
#include <string>
#include "treap.h" // class's header file

// class constructor
Treap::Treap()
{
	_root=new tNode();
}

// class destructor
Treap::~Treap()
{
	// insert your code here
}

void Treap::insert(string k, int v)
{

int priority=randomP();    
if (_root->isDummy())
{
    _root->unDummy(k,v,priority);
    return;
}

tNode* aux=_root;
tNode* auxFather=0;
bool lastLeft=true;
while(!aux->isDummy())
{
    int comparison=cmp(aux->getKey(),k);
    
    //si es 0 son iguales -> encontramos str
    
    if(comparison>=0)//me voy a la izquierda
    {
        auxFather=aux;
        aux=aux->Left();
        lastLeft=true;
               
    }
    
    else//me voy a la derecha
    {
        auxFather=aux;
        aux=aux->Right();
        lastLeft=false;
    }
}
    aux->unDummy(k,v,priority);
    
        int rootPty=auxFather->getPriority();
        int sonPty=aux->getPriority();
        
        if(lastLeft){ 
            
        if(sonPty>rootPty)
        {
            rotRight(auxFather);
        }
        }
        else{
        
        if(sonPty>rootPty)
        {
            rotLeft(auxFather);
        }
        
        }
    return;
}

void Treap::remove(string k)
{
    tNode* aux=findNode(k);
    if(aux==0)
    {
        return;
    }
    cout<<"elemento encontrado para eliminar:"<<aux->getValue()<<endl;
    
    while(!aux->isDummy()){
    cout<<"elemento aux:"<<aux->getValue()<<endl;
    cout<<"elemento left:"<<aux->Left()->getValue()<<endl;
    cout<<"elemento Right:"<<aux->Right()->getValue()<<endl;
    if(aux->isDummy())
    {
        return;
    }
    
    else if(aux->Left()->isDummy()&&aux->Right()->getValue()){
        cout<<"elemento eliminado"<<endl;
        aux->setDummy();
        //cout<<"elemento eliminado"<<endl;
        return;
        //debo eliminar ademàs los dummies con un delete (falta implementar destructor)
    }
    else if(aux->Left()->isDummy())
    {
        rotLeft(aux);
        aux=aux->Left();
        continue;
    }
    else if(aux->Right()->isDummy())
    {
        rotRight(aux);
        aux=aux->Right();
        continue;
    }
    else if(aux->Left()->getPriority()>aux->Right()->getPriority())
    {
        rotRight(aux);
        aux=aux->Right();
        continue;
    }
    else {
        rotLeft(aux);
        aux=aux->Left();
        continue;
    }
    }
}
tNode* Treap::findNode(string str)
{

if (_root->isDummy())
{
    return _root;
}
tNode* aux=_root;
while(!aux->isDummy())
{
    if(aux->isDummy())
    {
        return 0;//clave no encontrada
    }
    int comparison=cmp(aux->getKey(),str);
    
    //si es 0 son iguales -> encontramos str
    
    if(comparison==0)
    {
        return aux;
    }
    else if(comparison==1)//si es 1 busco str a la izquierda
    {
        
        aux=aux->Left();
    }
    
    else if(comparison==-1)//si es -1 busco str a la izquierda
    {
        aux=aux->Right();
    }
    
    
}
   
}

int Treap::find(string str)
{
    return findNode(str)->getValue();
}
int Treap::min()
{
    return 0;
}
int Treap::max()
{
    return 0;
}
void Treap::prettyPrint ( )
{
    tNode* aux = _root;
	
	

    stack<tNode*> sNodes;
	stack<bool> sMoves;

    while ( !aux->isDummy() || sNodes.empty() )
    {
        while (!aux->isDummy()) {
            sNodes.push (aux);
            
			aux = aux->Left();
			sMoves.push(false);
			
        }
        aux = sNodes.top();
		sNodes.pop();
		sMoves.pop();
		string relleno="";
		
		stack<bool> s=sMoves;//hago una copia
		bool last=s.top();
		s.pop();
		while (! s.empty() )
		  {
			if(last==s.top())
			{
			relleno=relleno+"   ";
			}
			else
			{
			relleno=relleno+"|  ";
			}
		  }
		if(aux==_root)
		{
		cout<<"--"<<aux->getKey()<<endl;
		}
		else
		{
		cout<<"   "<<relleno<<"|--"<<aux->getKey()<<endl;
		}
        
		
        aux = aux->Right();
		sMoves.push(true);
		
    }
}

void Treap::sortedDump ( )
{
    tNode* aux = _root;
	
	

    stack<tNode*> sNodes;
	

    while ( !aux->isDummy() || sNodes.empty() )
    {
        while (!aux->isDummy()) {
            sNodes.push (aux);       
			aux = aux->Left();		
        }
        aux = sNodes.top();
		sNodes.pop();
		
		cout<<aux->getKey()<<" "<<aux->getValue()<<endl;

        aux = aux->Right();
		
		
    }
}

tNode* Treap::rotLeft(tNode* subRoot) //rota a la izquierda y retorna nueva subraíz
{
    tNode* p=subRoot;
    tNode* q=p->Left();
    tNode* a=p->Left();
    tNode* b=q->Left();
    tNode* c=q->Right();
    
    q->setLeft(p);
    p->setRight(b);
    return q;
}

tNode* Treap::rotRight(tNode* subRoot) //rota a la izquierda y retorna nueva subraíz
{
    tNode* q=subRoot;
    tNode* p=q->Left();
    tNode* a=p->Left();
    tNode* b=p->Right();
    tNode* c=q->Right();
    
    p->setRight(q);
    q->setLeft(b);
    return p;
}

// Class automatically generated by Dev-C++ New Class wizard

#include "treap.h" // class's header file

// class constructor
Treap::Treap()
{
	// insert your code here
}

// class destructor
Treap::~Treap()
{
	// insert your code here
}

void Treap::insert(string k, int v)
{

int priority=randomP();    
if (_root->isDummy())
{
    _root->unDummy(k,v,priority);
    return;
}

tNode* aux=_root;
tNode* auxFather=0;
bool lastLeft=true;
while(!aux->isDummy())
{
    int comparison=cmp(aux->getKey(),k);
    
    //si es 0 son iguales -> encontramos str
    
    if(comparison>=0)//me voy a la izquierda
    {
        auxFather=aux;
        aux=aux->Left();
        lastLeft=true;
               
    }
    
    else//me voy a la derecha
    {
        auxFather=aux;
        aux=aux->Right();
        lastLeft=false;
    }
}
    aux->unDummy(k,v,priority);
    
        int rootPty=auxFather->getPriority();
        int sonPty=aux->getPriority();
        
        if(lastLeft){ 
            
        if(sonPty>rootPty)
        {
            rotRight(auxFather);
        }
        }
        else{
        
        if(sonPty>rootPty)
        {
            rotLeft(auxFather);
        }
        
        }
    return;
}

void Treap::remove(string k)
{
    tNode* aux=findNode(k);
    if(aux==0)
    {
        return;
    }
    while(!aux->isDummy()){
    if(aux->isDummy())
    {
        return;
    }
    else if(aux->Left()->isDummy()&&aux->Right()->isDummy()){
        aux->setDummy();
        return;
        //debo eiliminar ademàs los dummies con un delete (falta implementar destructor)
    }
    else if(aux->Left()->isDummy())
    {
        rotLeft(aux);
        aux=aux->Left();
    }
    else if(aux->Right()->isDummy())
    {
        rotRight(aux);
        aux=aux->Right();
    }
    else if(aux->Left()->getPriority()>aux->Right()->getPriority())
    {
        rotRight(aux);
        aux=aux->Right();
    }
    else {
        rotLeft(aux);
        aux=aux->Left();
    }
    }
}
tNode* Treap::findNode(string str)
{

if (_root->isDummy())
{
    return _root;
}
tNode* aux=_root;
while(!aux->isDummy())
{
    if(aux->isDummy())
    {
        return 0;//clave no encontrada
    }
    int comparison=cmp(aux->getKey(),str);
    
    //si es 0 son iguales -> encontramos str
    
    if(comparison==0)
    {
        return aux;
    }
    else if(comparison==1)//si es 1 busco str a la izquierda
    {
        
        aux=aux->Left();
    }
    
    else if(comparison==-1)//si es -1 busco str a la izquierda
    {
        aux=aux->Right();
    }
    
    
}
   
}

int Treap::find(string str)
{
    return findNode(str)->getValue();
}
int Treap::min()
{
    return 0;
}
tNode* Treap::rotLeft(tNode* subRoot) //rota a la izquierda y retorna nueva subraíz
{
    tNode* p=subRoot;
    tNode* q=p->Left();
    tNode* a=p->Left();
    tNode* b=q->Left();
    tNode* c=q->Right();
    
    q->setLeft(p);
    p->setRight(b);
    return q;
}

tNode* Treap::rotRight(tNode* subRoot) //rota a la izquierda y retorna nueva subraíz
{
    tNode* q=subRoot;
    tNode* p=q->Left();
    tNode* a=p->Left();
    tNode* b=p->Right();
    tNode* c=q->Right();
    
    p->setRight(q);
    q->setLeft(b);
    return p;
}

// Class automatically generated by Dev-C++ New Class wizard
#include <stack>
#include <iostream>
#include <string>
#include "treap.h" // class's header file

// class constructor
Treap::Treap()
{
	_root=new tNode(0);
	//_root->setFather(_root);
    //_root.setFather();
}

// class destructor
Treap::~Treap()
{
	// insert your code here
}

tNode* Treap::insertNode(tNode* nodo,string k,int v,int p)
{

if(nodo->isDummy())//es dummy
	{
	nodo->unDummy(k,v,p);
	}
else{
	int comparison=cmp(k,nodo->getKey());

	if(comparison==0)
		{
            cout<<"cambia valor"<<endl;
		nodo->setValue(v);
		//cambia valor;
		}	
	else if(comparison==-1)
		{
        cout<<"Bajo a la IZQUIERDA"<<endl;
		nodo->setLeft(insertNode(nodo->Left(),k,v,p));
		if(nodo->Left()->getPriority() < nodo->getPriority())
		{
		cout<<"* ROT RIGHT: "<<nodo->getKey()<<endl;
        nodo=rotRight(nodo);
		
		//rotacion derecha del nodo
		}
        }
	else if (comparison==1)//k> nodo->getKey()
		{
        cout<<"Bajo a la DERECHA"<<endl;
		nodo->setRight(insertNode(nodo->Right(),k,v,p));              
		if (nodo->Right()->getPriority() < nodo->getPriority()) 
		{
        cout<<"* ROT LEFT :"<<nodo->getKey()<<endl;
        nodo=rotLeft(nodo);
		
		//		t=lrot(t);  ROTACION IZQUIERDA          
		}
        }
}
cout<<"aux nodo: ("<<nodo->getKey()<<","<<nodo->getValue()<<","<<nodo->getPriority()<<")"<<endl;
cout<<"LEFT:"<<nodo->Left()->getKey()<<" RIGHT:"<<nodo->Right()->getKey()<<endl;
cout<<endl;
return nodo;
}

void Treap::insert(string k, int v)
{

    int p=randomP();/*
    if(findNode(k)!=0)
    {
        findNode(k)->setValue(v);
        return;
    }*/
    
    insertNode(_root,k, v, p);
    cout<<"[Insertado]: ---> ("<<k<<","<<v<<","<<p<<")"<<endl;
    cout<<endl<<"------------------"<<endl;

}

void Treap::remove(string k)
{
    tNode* aux=findNode(k);
    if(aux==0)
    {
        return;
    }
    cout<<"elemento encontrado para eliminar:"<<aux->getValue()<<endl;
    
    while(!aux->isDummy()){
    cout<<"elemento aux:"<<aux->getValue()<<endl;
    cout<<"elemento left:"<<aux->Left()->getValue()<<endl;
    cout<<"elemento Right:"<<aux->Right()->getValue()<<endl;
    if(aux->isDummy())
    {
        return;
    }
    
    else if(aux->Left()->isDummy()&&aux->Right()->getValue()){
        cout<<"elemento eliminado"<<endl;
        aux->setDummy();
        //cout<<"elemento eliminado"<<endl;
        return;
        //debo eliminar ademàs los dummies con un delete (falta implementar destructor)
    }
    else if(aux->Left()->isDummy())
    {
        rotLeft(aux);
        aux=aux->Left();
        continue;
    }
    else if(aux->Right()->isDummy())
    {
        rotRight(aux);
        aux=aux->Right();
        continue;
    }
    else if(aux->Left()->getPriority()>aux->Right()->getPriority())
    {
        rotRight(aux);
        aux=aux->Right();
        continue;
    }
    else {
        rotLeft(aux);
        aux=aux->Left();
        continue;
    }
    }
}
tNode* Treap::findNode(string str)
{

if (_root->isDummy())
{
    return 0;
}
tNode* aux=_root;
while(!aux->isDummy())
{
    //cout<<"DUMMY->"<<aux->isDummy()<<endl;
    
    int comparison=cmp(aux->getKey(),str);
    //cout<<"cmpcion"<<comparison<<endl;
    //si es 0 son iguales -> encontramos str
    
    if(comparison==0)
    {
        //cout<<"encontrado k:"<<aux->getKey()<<endl;
        return aux;
        
    }
    else if(comparison==1)//si es 1 busco str a la izquierda
    {
        //cout<<"IZQ"<<endl;
        aux=aux->Left();
    }
    
    else if(comparison==-1)//si es -1 busco str a la dercha
    {
        //cout<<"DER"<<endl;
        aux=aux->Right();
    }
    
    
}
 if(aux->isDummy())
    {
        //cout<<"NO ESTA"<<endl;
        return 0;//clave no encontrada
       
    }  
}

int Treap::find(string str)
{
    return findNode(str)->getValue();
}
int Treap::min()
{
    return 0;
}
int Treap::max()
{
    return 0;
}
void Treap::prettyPrint ( )
{
    tNode* aux = _root;
	
	

    stack<tNode*> sNodes;
	stack<bool> sMoves;

    while ( !aux->isDummy() || sNodes.empty() )
    {
        while (!aux->isDummy()) {
            sNodes.push (aux);
            
			aux = aux->Left();
			sMoves.push(false);
			
        }
        aux = sNodes.top();
		sNodes.pop();
		sMoves.pop();
		string relleno="";
		
		stack<bool> s=sMoves;//hago una copia
		bool last=s.top();
		s.pop();
		while (! s.empty() )
		  {
			if(last==s.top())
			{
			relleno=relleno+"   ";
			}
			else
			{
			relleno=relleno+"|  ";
			}
		  }
		if(aux==_root)
		{
		cout<<"--"<<aux->getKey()<<endl;
		}
		else
		{
		cout<<"   "<<relleno<<"|--"<<aux->getKey()<<endl;
		}
        
		
        aux = aux->Right();
		sMoves.push(true);
		
    }
}

void Treap::sortedDump ( )
{

    inorderPrint(_root);
    
}

void Treap::inorderPrint(tNode* currentNode)
{
    if(!currentNode->isDummy())
    {
        cout<<"Rec: "<<currentNode->getKey()<<" P: "<<currentNode->getPriority()<<endl;
        cout<<"Left:"<<currentNode->Left()->getKey()<<" Right:"<<currentNode->Right()->getKey()<<endl;
    }
    if (!currentNode->isDummy()) {
       inorderPrint(currentNode->Left());
       cout << currentNode->getKey()<<" "<<currentNode->getValue()<<endl;
       inorderPrint(currentNode->Right());
    }
}

tNode* Treap::rotLeft(tNode* subRoot) //rota a la izquierda y retorna nueva subraíz
{
    
    
    tNode* p=subRoot;
    tNode* q=p->Right();
    tNode* a=p->Left();
    tNode* b=q->Left();
    tNode* c=q->Right();
    //p->setFather(q);
    q->setLeft(p);
    //b->setFather(p);
    p->setRight(b);
    return q;
    
 

}

tNode* Treap::rotRight(tNode* t) //rota a la izquierda y retorna nueva subraíz
{
    
    tNode *q, *p, *a, *b, *c;

    q=t;
    p=q->Left();
    a=p->Left();
    b=p->Right();
    c=q->Right();

    //q->setFather(p);
    p->setRight(q);

    //b->setFather(q);
    q->setLeft(p->Right());


    cout<<"* root:"<<p->getKey()<<" left:"<<p->Left()->getKey()<<" right:"<<p->Right()->getKey()<<endl;
    return p;               
    
    
}
